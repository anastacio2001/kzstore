/**
 * Orders Service - Sistema Completo de Pedidos para API Local (Prisma/MySQL)
 * @author KZSTORE
 * @description Gerenciamento de pedidos com validação de estoque, cálculos e atualizações
 */

import { getAuthHeaders } from '../../utils/api';

const API_BASE = '/api';

// Types
export interface OrderItem {
  product_id: string;
  product_name: string;
  product_image: string;
  quantity: number;
  price: number;
  subtotal: number;
}

export interface ShippingAddress {
  full_name: string;
  phone: string;
  province: string;
  city: string;
  address: string;
  postal_code?: string;
  landmark?: string;
}

export interface Order {
  id: string;
  order_number: string;
  user_id: string;
  user_email: string;
  user_name: string;
  items: OrderItem[];
  subtotal: number;
  shipping_cost: number;
  discount_amount: number;
  discount_type?: 'coupon' | 'loyalty_points' | 'flash_sale' | 'b2b';
  discount_details?: string;
  tax_amount: number;
  total: number;
  status: 'pending' | 'processing' | 'shipped' | 'delivered' | 'cancelled' | 'refunded';
  payment_method: 'multicaixa' | 'bank_transfer' | 'cash_on_delivery';
  payment_status: 'pending' | 'paid' | 'failed' | 'refunded';
  shipping_address: ShippingAddress;
  notes?: string;
  tracking_number?: string;
  created_at: string;
  updated_at: string;
  delivered_at?: string;
  cancelled_at?: string;
}

export interface CreateOrderData {
  user_id: string;
  user_email: string;
  user_name: string;
  items: OrderItem[];
  subtotal: number;
  shipping_cost: number;
  discount_amount: number;
  discount_type?: string;
  discount_details?: string;
  tax_amount: number;
  total: number;
  payment_method: string;
  shipping_address: ShippingAddress;
  notes?: string;
}

export interface OrderStats {
  total_orders: number;
  total_revenue: number;
  pending_orders: number;
  processing_orders: number;
  shipped_orders: number;
  delivered_orders: number;
  cancelled_orders: number;
  average_order_value: number;
  today_orders: number;
  today_revenue: number;
}

/**
 * Gera número único de pedido
 */
function generateOrderNumber(): string {
  const date = new Date();
  const year = date.getFullYear().toString().slice(-2);
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  const random = Math.floor(Math.random() * 9000) + 1000; // 4 dígitos
  return `KZ${year}${month}${day}-${random}`;
}

/**
 * Buscar todos os pedidos (Admin)
 */
export async function getAllOrders(): Promise<Order[]> {
  try {
    const authHeaders = getAuthHeaders();
    const response = await fetch(`${API_BASE}/orders?limit=100`, {
      credentials: 'include',
      headers: {
        'Content-Type': 'application/json',
        ...authHeaders
      }
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('❌ [ordersService] Failed to fetch orders:', errorText);
      throw new Error('Failed to fetch orders');
    }

    const data = await response.json();
    return data.data || data.orders || [];
  } catch (error) {
    console.error('❌ Erro ao buscar todos os pedidos:', error);
    throw error;
  }
}

/**
 * Buscar pedidos do usuário
 */
export async function getUserOrders(userId: string): Promise<Order[]> {
  try {
    const authHeaders = getAuthHeaders();
    const response = await fetch(`${API_BASE}/orders?user_id=${userId}`, { 
      credentials: 'include',
      headers: authHeaders
    });
    if (!response.ok) throw new Error('Failed to fetch user orders');
    const data = await response.json();
    return data.data || data.orders || [];
  } catch (error) {
    console.error('❌ Erro ao buscar pedidos do usuário:', error);
    throw error;
  }
}

/**
 * Buscar pedido por ID
 */
export async function getOrderById(orderId: string): Promise<Order | null> {
  try {
    const authHeaders = getAuthHeaders();
    const response = await fetch(`${API_BASE}/orders/${orderId}`, { 
      credentials: 'include',
      headers: authHeaders
    });
    if (!response.ok) throw new Error('Failed to fetch order');
    const data = await response.json();
    return data.order;
  } catch (error) {
    console.error('❌ Erro ao buscar pedido:', error);
    return null;
  }
}

/**
 * Validar estoque antes de criar pedido
 */
export async function validateStock(items: OrderItem[]): Promise<{
  valid: boolean;
  errors: string[];
}> {
  const errors: string[] = [];


  for (const item of items) {
    try {
      
      // Buscar produto via API
      const response = await fetch(`${API_BASE}/products/${item.product_id}`);
      if (!response.ok) {
        console.error(`❌ [VALIDATE STOCK] Product not found: ${item.product_id}`);
        errors.push(`Produto "${item.product_name}" não encontrado`);
        continue;
      }

      const data = await response.json();
      const product = data.product;


      const currentStock = product.estoque || 0;
      if (currentStock < item.quantity) {
        console.error(`❌ [VALIDATE STOCK] Insufficient stock for ${product.nome}. Available: ${currentStock}, Requested: ${item.quantity}`);
        errors.push(
          `Estoque insuficiente para "${product.nome}". Disponível: ${currentStock}, Solicitado: ${item.quantity}`
        );
      }
    } catch (error) {
      console.error(`❌ [VALIDATE STOCK] Error validating product "${item.product_name}":`, error);
      errors.push(`Erro ao validar produto "${item.product_name}"`);
    }
  }


  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Criar novo pedido
 */
export async function createOrder(orderData: CreateOrderData): Promise<Order> {
  try {

    // 1. Validar estoque
    const stockValidation = await validateStock(orderData.items);
    if (!stockValidation.valid) {
      throw new Error(`Validação de estoque falhou:\n${stockValidation.errors.join('\n')}`);
    }

    // 2. Criar pedido
    const orderNumber = generateOrderNumber();
    const order = {
      order_number: orderNumber,
      user_id: orderData.user_id,
      user_email: orderData.user_email,
      user_name: orderData.user_name,
      items: orderData.items,
      subtotal: orderData.subtotal,
      shipping_cost: orderData.shipping_cost,
      discount_amount: orderData.discount_amount,
      discount_type: orderData.discount_type,
      discount_details: orderData.discount_details,
      tax_amount: orderData.tax_amount,
      total: orderData.total,
      status: 'pending',
      payment_method: orderData.payment_method,
      payment_status: 'pending',
      shipping_address: orderData.shipping_address,
      notes: orderData.notes,
    };

    // 3. Salvar via API
    const authHeaders = getAuthHeaders();
    const response = await fetch(`${API_BASE}/orders`, {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json',
        ...authHeaders
      },
      body: JSON.stringify(order),
      credentials: 'include'
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || 'Failed to create order');
    }

    const data = await response.json();

    // 4. Atualizar estoque
    for (const item of orderData.items) {
      try {
        await fetch(`${API_BASE}/products/${item.product_id}/stock`, {
          method: 'PATCH',
          headers: { 
            'Content-Type': 'application/json',
            ...authHeaders
          },
          body: JSON.stringify({ quantity: -item.quantity }),
        });
      } catch (error) {
        console.error(`❌ Erro ao atualizar estoque do produto ${item.product_id}:`, error);
      }
    }

    return data.order;
  } catch (error) {
    console.error('❌ [CREATE ORDER] Erro ao criar pedido:', error);
    throw error;
  }
}

/**
 * Atualizar status do pedido
 */
export async function updateOrderStatus(
  orderId: string,
  status: Order['status'],
  additionalData?: Partial<Order>
): Promise<Order> {
  try {
    
    const updateData: any = {
      status,
      updated_at: new Date().toISOString(),
      ...additionalData,
    };

    // Adicionar timestamp específico baseado no status
    if (status === 'delivered') {
      updateData.delivered_at = new Date().toISOString();
    } else if (status === 'cancelled') {
      updateData.cancelled_at = new Date().toISOString();
    }

    // Atualizar via API
    const authHeaders = getAuthHeaders();
    const response = await fetch(`${API_BASE}/orders/${orderId}/status`, {
      method: 'PATCH',
      headers: { 
        'Content-Type': 'application/json',
        ...authHeaders
      },
      body: JSON.stringify(updateData),
      credentials: 'include'
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || 'Failed to update order status');
    }

    const data = await response.json();
    return data.order;
  } catch (error) {
    console.error('❌ Erro ao atualizar status do pedido:', error);
    throw error;
  }
}

/**
 * Atualizar status de pagamento
 */
export async function updatePaymentStatus(
  orderId: string,
  paymentStatus: Order['payment_status']
): Promise<Order> {
  try {
    const authHeaders = getAuthHeaders();
    const response = await fetch(`${API_BASE}/orders/${orderId}/payment`, {
      method: 'PATCH',
      headers: { 
        'Content-Type': 'application/json',
        ...authHeaders
      },
      body: JSON.stringify({ payment_status: paymentStatus }),
      credentials: 'include'
    });

    if (!response.ok) throw new Error('Failed to update payment status');

    const data = await response.json();
    return data.order;
  } catch (error) {
    console.error('❌ Erro ao atualizar status de pagamento:', error);
    throw error;
  }
}

/**
 * Adicionar número de rastreamento
 */
export async function addTrackingNumber(
  orderId: string,
  trackingNumber: string
): Promise<Order> {
  try {
    const authHeaders = getAuthHeaders();
    const response = await fetch(`${API_BASE}/orders/${orderId}/tracking`, {
      method: 'PATCH',
      headers: { 
        'Content-Type': 'application/json',
        ...authHeaders
      },
      body: JSON.stringify({ tracking_number: trackingNumber, status: 'shipped' }),
      credentials: 'include'
    });

    if (!response.ok) throw new Error('Failed to add tracking number');

    const data = await response.json();
    return data.order;
  } catch (error) {
    console.error('❌ Erro ao adicionar número de rastreamento:', error);
    throw error;
  }
}

/**
 * Cancelar pedido (e reverter estoque)
 */
export async function cancelOrder(orderId: string, reason?: string): Promise<Order> {
  try {
    // Buscar pedido
    const order = await getOrderById(orderId);
    if (!order) throw new Error('Pedido não encontrado');

    // Reverter estoque
    
    for (const item of order.items) {
      const product = await getProductById(item.product_id);

      if (!product) {
        console.error(`❌ [CANCEL ORDER] Product not found: ${item.product_id}`);
        continue; // Continua revertendo outros produtos
      }

      const oldStock = product.estoque || 0;
      const newStock = oldStock + item.quantity;
      

      // Incrementar estoque (quantidade positiva para adicionar)
      await updateProductStock(item.product_id, item.quantity);

    }

    // Atualizar pedido
    const updatedOrder = await updateOrderStatus(orderId, 'cancelled', {
      cancelled_at: new Date().toISOString(),
      notes: reason ? `${order.notes || ''}\nMotivo do cancelamento: ${reason}` : order.notes,
    });

    return updatedOrder;
  } catch (error) {
    console.error('❌ Erro ao cancelar pedido:', error);
    throw error;
  }
}

/**
 * Buscar estatísticas de pedidos (Dashboard Admin)
 */
export async function getOrderStats(): Promise<OrderStats> {
  try {
    const orders = await getAllOrders();

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const stats: OrderStats = {
      total_orders: orders.length,
      total_revenue: orders.reduce((sum, order) => sum + order.total, 0),
      pending_orders: orders.filter((o) => o.status === 'pending').length,
      processing_orders: orders.filter((o) => o.status === 'processing').length,
      shipped_orders: orders.filter((o) => o.status === 'shipped').length,
      delivered_orders: orders.filter((o) => o.status === 'delivered').length,
      cancelled_orders: orders.filter((o) => o.status === 'cancelled').length,
      average_order_value: orders.length > 0 ? orders.reduce((sum, order) => sum + order.total, 0) / orders.length : 0,
      today_orders: orders.filter((o) => new Date(o.created_at) >= today).length,
      today_revenue: orders
        .filter((o) => new Date(o.created_at) >= today)
        .reduce((sum, order) => sum + order.total, 0),
    };

    return stats;
  } catch (error) {
    console.error('❌ Erro ao buscar estatísticas de pedidos:', error);
    throw error;
  }
}

/**
 * Buscar pedidos por status
 */
export async function getOrdersByStatus(status: Order['status']): Promise<Order[]> {
  try {
    const orders = await getAllOrders();
    return orders.filter(o => o.status === status);
  } catch (error) {
    console.error(`❌ Erro ao buscar pedidos com status ${status}:`, error);
    throw error;
  }
}

/**
 * Buscar pedidos recentes (últimos N dias)
 */
export async function getRecentOrders(days: number = 7): Promise<Order[]> {
  try {
    const date = new Date();
    date.setDate(date.getDate() - days);

    const orders = await getAllOrders();
    return orders.filter(o => new Date(o.created_at) >= date);
  } catch (error) {
    console.error(`❌ Erro ao buscar pedidos dos últimos ${days} dias:`, error);
    throw error;
  }
}

/**
 * Deletar pedido (apenas admin)
 */
export async function deleteOrder(orderId: string): Promise<void> {
  try {
    const authHeaders = getAuthHeaders();
    const response = await fetch(`${API_BASE}/orders/${orderId}`, {
      method: 'DELETE',
      headers: authHeaders,
    });

    if (!response.ok) throw new Error('Failed to delete order');
  } catch (error) {
    console.error('❌ Erro ao deletar pedido:', error);
    throw error;
  }
}

/**
 * Atualizar estoque após pedido - reduz o estoque
 */
async function reduceProductStock(items: OrderItem[]): Promise<void> {
  
  for (const item of items) {
    try {
      // Buscar produto atual
      const product = await getProductById(item.product_id);

      if (!product) {
        console.error(`❌ [UPDATE STOCK] Product not found: ${item.product_id}`);
        throw new Error(`Produto \"${item.product_name}\" não encontrado`);
      }

      // Calcular novo estoque
      const oldStock = product.estoque || 0;
      const newStock = Math.max(0, oldStock - item.quantity);
      

      // Atualizar produto no Supabase
      await updateProductStock(item.product_id, -item.quantity);

    } catch (error) {
      console.error(`❌ [UPDATE STOCK] Error updating stock for ${item.product_name}:`, error);
      throw error;
    }
  }
  
}